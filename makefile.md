# Makefiles

# Introduction

A primary usage of make is to compile and links source code ordered by prerequisites.

# Lesson01

Make sure you are in the right directory

```
cd lesson01
```

## Running Make

By default, make runs against a file named **Makefile**.

```markdown
$ make
$ make -f makefile_01
```

Use the *-f* or *--file* flag to run make against another file.

See [Running Make - Advanced](#running-make-advanced) for additional make options.

## Make File

Makefiles contain:

- **[Rules](#rules)** - Describes how to make a file (or type of file)
- **[Variables](#variables)** - specifies a text string value for a variable that can be substituted into the text later.
- **[Comments](#comments)** - comment in a makefile

## Rules

We define an **explicit rule** as follows:

```markdown
target : normal-prerequisites
	recipe

# WARNING: The recipe MUST be preceded by a tab character	
```

- **target** - name of file we want to make
    - see also [Rules - Phony Rules](#rules-phony-rules)
    - **Warning:** By default, **make runs the first rule in a make file**.
- **normal-prerequisites** - Other targets required **before** this target can be made
	- note: The recipe of a target is not ran if none of the dependencies changed (a powerful feature of make)
	- see see [Rules - Advanced](#rules-advanced)
- **recipe** - One or more commands to execute on the command line
	- **MUST** start with a tab character to be treated as a recipe

A rule can be seen as a goal which is a target make stives to update.

### Example 01 - lesson01/makefile_01

We have three files add.h, add.cpp and main.cpp. To build a program called add, we need to run g++ to compile and build the object files add.cpp and main.cpp. We then need to use g++ to link the two object files into a final executable. On the command line, we would need to do something like this:

```markdown
$ g++ -c -std=gnu++11 add.cpp -o add.o
$ g++ -c -std=gnu++11 main.cpp -o main.o
$ g++ -std=c++11 -Wextra -Wall add.o main.o -o add
$ ./add   // run it
```

Using a make file, we want to build an executable named *add*. add is the executable target with two prerequisites: add.o and main.o

```markdown
add: add.o main.o
	g++ -std=c++11 -Wextra -Wall add.o main.o -o add
```

We will need to add rules on how to build add.o and main.o:

```markdown
add.o: add.cpp
	g++ -c -std=gnu++11 add.cpp -o add.o

main.o: main.cpp
	g++ -c -std=gnu++11 main.cpp -o main.o
```

The files add.cpp and main.cpp don't need to be "made" because they are created by us. However, add.o and main.o depend on add.cpp and main.cpp respectively. So, we add them to the prerequisites.

The final make file looks like this:

```markdown
add: add.o main.o
	g++ -std=c++11 -Wextra -Wall add.o main.o -o add

add.o: add.cpp
	g++ -c -std=gnu++11 add.cpp -o add.o

main.o: main.cpp
	g++ -c -std=gnu++11 main.cpp -o main.o
```

## Runing a Rule

To run a rule other than the default rule, provide the name of the rule in the command line.

```makefile
$ make -f makefile_01 main.o
```

Causes the rule main.o in makefile_01 to run.

## Comments

Comments start with a # causing the rest of the line to be ignored.

```makefile
# This makefile only has a comment
```

- To get a literal #, escape it with \\#
- also see [Comments Advanced](comments-advanced)

## Variables

Makefile_01 has a lot of repetition which we can remove by using variables.

Defining a deferred variable is done using the '=' symbol as follows:

```makefile
CC		= g++
```

Using a variable is done as follows:

```markdown
add: add.o main.o
	$(CC) -std=c++11 -Wextra -Wall add.o main.o -o add
```

Notice text 'g++' in the recipe is now replaced by $(CC). Make will replace any $(CC) with the literal value 'g++'.

A variable specifies a text string value for a variable that can be substituted into the text later.

### Example 02 Variables - lesson01/makefile_02

Let's define and use best standard variables:

```markdown
CC		= g++
CFLAGS	= -Ofast -c -std=c++11 -Wextra -Wall
LDFLAGS	= -std=c++11 -Wextra -Wall
OBJ		= add.o main.o
EXE		= add

$(EXE): $(OBJ)
	$(CC) $(LDFLAGS) $(OBJ) -o $(EXE)

add.o: add.cpp
	$(CC) $(CFLAGS) add.cpp -o add.o

main.o: main.cpp
	$(CC) $(CFLAGS) main.cpp -o main.o
```

We are even able to use variables for the taget name as can be seen by the EXE variable.

Again notice that $(OBJ) is replaced by the literal text 'add.o main.o'.

## Rules - Phony Rules 

A rule that **does not** create a file is called a phony rule. By convention, we can make a phony rule. Let's add in rules to remove any files generated by our makefile: all object files and the executable itself.

#### Example 03 Phony Rules - lesson01/makefile_03

Added to the end of makefile_02:

```makefile
.PHONY : clean

clean :
	-rm -f $(OBJ) $(EXE)
```

- prefixing a rule with a . marks it as phony so make doesn't accidentally try to create an actual file called clean
- Placing a '-' to the beginning of the recipe ignores errors.

We can now clean any files by running the following:

```
$ make -f makefile_03 clean
```

# Lesson02

## Directories and Project Layout

[Makefile and g++ Directories](https://stackoverflow.com/questions/1814270/gcc-g-option-to-place-all-object-files-into-separate-directory)

Source code should be located in a directory other than root (such as src). We'll describe a way of laying out our project (by convention).

We need to let both the compiler and make know where our files are.

## Make and vpath

vpath (note lower case) is used to setup a 'search path' to locate types of files like header files, source code files, etc.

Let's setup a vpath for our header and source files

```makefile
vpath %.h inc
vpath %.cpp src
```

If you fail to setup the vpath you may get an error like: "make: *** No rule to make target `x`. Stop."















### Running Make - Advanced

```
$ make -k or make --keep-going
```

```
$ make -r // remove implicit rules
```

```
$ make -d // debug
```

### Rules - Advanced

```
target ... : normal-prerequisites | ordered-only-prerequisites... \
	recipe
   ...
```

- see .DELETE_ON_ERROR in target






## Implicit Rules

Implicit Rules (cc -c main.c -o main.o is already there)


### Comments - Advanced

TODO: Simplify these rules for comments

- You cannot use comments within variable references or function calls: any instance of # will be treated literally (rather than as the start of a comment) inside a variable reference or function call.
- Comments within a recipe are passed to the shell, just as with any other recipe text. The shell decides how to interpret it: whether or not this is a comment is up to the shell.
- Within a define directive, comments are not ignored during the definition of the variable, but rather kept intact in the value of the variable. When the variable is expanded they will either be treated as make comments or as recipe text, depending on the context in which the variable is evaluated.


### Splitting Long Lines

Use the \ to split long lines

```markdown
add: add.o \
     main.o
	g++ -std=c++11 -Wextra -Wall add.o main.o -o add
```

Notice main.o is no longer on the same line as add.o but it is still a prerequisites.


## TODO

- 3.3 Including Other Makefiles

